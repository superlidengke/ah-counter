<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<!-- https://github.com/superlidengke/ah-counter -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <script src="https://unpkg.com/vue@3"></script>
    <script src="record.js"></script>
    <style>
      svg:not(.sorted) rect {
          fill: orange;
      }
      svg text {
          fill:black;
          font: 15px sans-serif;
          text-anchor: end;
      }
      svg text.left-align {
        text-anchor: start;
      }
      svg text.middle-align {
        text-anchor: middle;
      }
      svg text.red {
          fill:red;
          font: 25px sans-serif;
      }
      .menu{
        margin-right: 5%;
        float: right;
      }
      button{
        margin-right: 20px;
      }
  </style>
  </head>
  <body>
    <div id="app">
      <div class="title">
        <span v-html="title"></span>
      </div>
      <div class="menu">
        <button id="drawByRole">By Role</button>
        <button id="drawSorted">Sorted</button>
        <button id="drawByWord">By Word</button>
      </div>
      <br/>
      <div class="panel">

      </div>
    </div> 

    <script>
      const { createApp } = Vue
      createApp({
        data() {
          return {
            title: record.title
          }
        }
      }).mount('#app')
    </script>
    <script type="module">
      import * as d3 from "https://cdn.skypack.dev/d3@7";
      const width = 1400;
      const perSpeakerHeight = 100;
      const perSpeakerWidth = width - 150;
      const speakerNameWidth = 100;
      const perItemWidth = 80;

    function getBorderColor(speaker){
      const role = speaker.role;
      if(role.startsWith("Table Topic")){
        return "green"
      }else if (role.startsWith("Prepared")){
        return "purple"
      }else if (role.includes("Evaluator")){
        return "blue"
      }else{
        return "black"
      }
    }

    function getFillColorByIndex(idx){
      const colorPool = ['#F87C7E','#F88F7F','#F9A381','#F9BB83','#FBCF85','#F4DC90','#EBE3A0','#E0EBB1','#D6F2C1','#CBFBD5'];
      if(idx < colorPool.length){
        return colorPool.at(idx)
      }else{
        return colorPool.at(-1)
      }
    }

    function clearDrawArea(){
      d3.select("div#app div.panel")
        .selectAll("svg")
        .remove()
    }

    function drawAllSpeakers(){
      clearDrawArea();
      record.speakers.forEach(speaker => {
      const speakerByRole = d3.select("div#app div.panel")
        .append("svg")
        .attr("width", width)
        .attr("height", perSpeakerHeight)
        .attr("style",`border:2px solid ${getBorderColor(speaker)}`)
      const speakerNameSvg = speakerByRole.append("text")
        .classed('left-align'  , true)
        .attr("x", 5)
        .attr("y", perSpeakerHeight/2)
      const [roleName, speakerName] = speaker.speaker.split('-')
      speakerNameSvg.append("tspan")
        .text(roleName)
      speakerNameSvg.append("tspan")
        .attr("x", 5)
        .attr("dy", 20)
        .text(speakerName)
      const fillerWordBar = speakerByRole.selectAll("g")
        .data(speaker.fillerWords.filter(it => {
          return it.count > 0;
        }).sort((a,b) => b.count-a.count)
        )
        .enter()
        .append("g")
        .attr("transform", function(d, i) {
              return `translate(${perItemWidth * i * 2+speakerNameWidth},0)`;
        });
      const maxCounter = Math.max(...speaker.fillerWords.map(it => it.count))
      function getHeight(d){
        return perSpeakerHeight * d.count/maxCounter - 10;
      }
      fillerWordBar.append("rect")
        .attr("width", perItemWidth)
        .attr("y", function(d){
          return perSpeakerHeight - getHeight(d);
        })
        .attr("height", function(d){
          return getHeight(d);
        });
      fillerWordBar.append("text")
       .attr("x", 0)
       .attr("y", perSpeakerHeight -5)
       .attr("dy", ".35em")
       .text(function(d) { 
         return d.word; 
        });
      fillerWordBar.append("text")
       .attr("x", perItemWidth/2)
       .attr("y", function(d){
          return perSpeakerHeight - getHeight(d)-2
       })
       .attr("dy", ".35em")
       .text(function(d) { 
         return d.count; 
        });
      });
    }

    function drawSortedSpeakers(){
      clearDrawArea()
      record.speakers.forEach(speaker => {
        const sumOfFillerWords = speaker.fillerWords
        .map(it => it.count)
        .reduce((a,b) => a+b,0)
        speaker.sumOfFillerWords = sumOfFillerWords;
      })
      
      const speakers = record.speakers.sort((a,b) => b.sumOfFillerWords - a.sumOfFillerWords)
      const maxSumOfFillerWords = speakers.at(0).sumOfFillerWords;
      speakers.forEach(speaker => {
        speaker.fillerWords = speaker.fillerWords.filter(it => {
            return it.count > 0;
          }).sort((a,b) => b.count-a.count)
        speaker.fillerWords.forEach((word, idx) => {
          word.idx = idx
        })
        const speakerSvg = d3.select("div#app div.panel")
          .append("svg")
          .classed("sorted", true)
          .attr("width", width)
          .attr("height", perSpeakerHeight/2)
          .attr("style",`border:1px solid ${getBorderColor(speaker)}`);
        const speakerNameSvg = speakerSvg.append("text")
          .classed('left-align'  , true)
          .attr("x", 5)
          .attr("y", perSpeakerHeight/4);
        const [roleName, speakerName] = speaker.speaker.split('-')
        speakerNameSvg.append("tspan")
          .text(roleName)
        speakerNameSvg.append("tspan")
          .attr("x", 5)
          .attr("dy", 20)
          .text(speakerName)
        let offSet = speakerNameWidth
        function figureOffset(fillerWord){
          const currentOffSet = offSet;
          offSet +=  perSpeakerWidth * fillerWord.count / maxSumOfFillerWords
          console.log(offSet)
          return currentOffSet
        }
        const fillerWordBar = speakerSvg.selectAll("g")
          .data(speaker.fillerWords)
          .enter()
          .append("g")
          .attr("transform", function(d, i) {
                return `translate(${figureOffset(d)},0)`;
          });

        fillerWordBar.append("rect")
          .attr("y", function(d){
            return perSpeakerHeight/10;
          })
          .attr("height", perSpeakerHeight/3)
          .attr('fill', function(d) {
              return getFillColorByIndex(d.idx) ;
          })
          .transition()
          .duration(1000)
          .attr("width", function (d) {
            return perSpeakerWidth * d.count / maxSumOfFillerWords;
          })
          ;
        fillerWordBar.append("text")
          .classed('left-align', true)
          .attr("x", 0)
          .attr("y", perSpeakerHeight/3)
          .attr("dy", ".35em")
          .text(function(d) { 
            return `${d.word}:${d.count}`; 
          });
        
        speakerSvg.append("text")
          .classed('left-align'  , true)
          .classed('red'  , true)
          .attr("x", offSet)
          .attr("y", perSpeakerHeight/5)
          .attr("dx", ".35em")
          .transition()
          .delay(1000)
          .text(speaker.sumOfFillerWords);
      })
    }

    function drawWordsPie(){
      clearDrawArea();
      const wordsPieSvg = d3.select("div#app div.panel")
          .append("svg")
          .attr("width", width)
          .attr("height", width/2)
       const pieWidth = wordsPieSvg.attr("width");
       const pieHeight = wordsPieSvg.attr("height");
       const radius = Math.min(pieWidth, pieHeight) / 2;
       const pieGroup = wordsPieSvg.append("g").attr("transform", "translate(" + pieWidth / 2 + "," + pieHeight / 2 + ")");
       const fillerWordsData =[];

       record.speakers.forEach(speaker => {
          const fillerWords = speaker.fillerWords.filter(it => it.count>0)
          fillerWords.forEach(fillerWord => {
            const wordCount = fillerWordsData.find(it => it.word === fillerWord.word)
            if(wordCount){
              wordCount.count += fillerWord.count
            }else{
              // avoid push fillerWord directly
              const newWordCount = {word:fillerWord.word,count:fillerWord.count}
              fillerWordsData.push(newWordCount)
            }
          })
        })

       const color = d3.scaleOrdinal(['#4daf4a','#377eb8','#ff7f00','#984ea3','#949a1c']);

      // Generate the pie
      const pie = d3.pie().value(function(d) { 
            return d.count; 
        });;

      // Generate the arcs
      const piePath = d3.arc()
            .innerRadius(0)
            .outerRadius(radius-10);
      
      const label = d3.arc()
            .outerRadius(radius)
            .innerRadius(radius - 100);

      //Generate groups
      const arcs = pieGroup.selectAll("arc")
            .data(pie(fillerWordsData))
            .enter()
            .append("g")
            .attr("class", "arc")

      //Draw arc paths
      arcs.append("path")
          .attr("fill", function(d, i) {
              return color(i);
          })
          .attr("d", piePath)
          .transition().duration(500)
          .attrTween('d', function (d) {
            const angleInterpolate = d3.interpolate(d.startAngle + 0.1, d.endAngle);
            return function (t) {
              d.endAngle = angleInterpolate(t);
              return piePath(d);
            }
        })

      arcs.append("text")
        .classed('middle-align', true)
        .attr("transform", function(d) { 
              return "translate(" + label.centroid(d) + ")"; 
            })
        .text(d => `${d.data.word}:${d.data.count}`);
    }
    d3.select("#drawByRole").on("click", drawAllSpeakers)
    d3.select("#drawSorted").on("click", drawSortedSpeakers)
    d3.select("#drawByWord").on("click", drawWordsPie)


    drawAllSpeakers();
    // drawSortedSpeakers();
    // drawWordsPie()

    </script>
  </body>
</html>
